# ATTENTION: auto generated from C++ code, use `make stubgen` to update!
"""
common module
"""
from __future__ import annotations

import typing

import numpy
import pybind11_stubgen.typing_ext

__all__ = [
    "BaseCameraConfig",
    "FR3",
    "FrankaHandTCPOffset",
    "GraspType",
    "Gripper",
    "GripperConfig",
    "GripperState",
    "HARDWARE",
    "Hand",
    "HandConfig",
    "HandState",
    "IK",
    "IdentityRotMatrix",
    "IdentityRotQuatVec",
    "IdentityTranslation",
    "LATERAL_GRASP",
    "POWER_GRASP",
    "PRECISION_GRASP",
    "Pin",
    "Pose",
    "RL",
    "RPY",
    "Robot",
    "RobotConfig",
    "RobotMetaConfig",
    "RobotPlatform",
    "RobotState",
    "RobotType",
    "SIMULATION",
    "SO101",
    "TRIPOD_GRASP",
    "UR5e",
    "XArm7",
    "robots_meta_config",
]
M = typing.TypeVar("M", bound=int)
N = typing.TypeVar("N", bound=int)

class BaseCameraConfig:
    frame_rate: int
    identifier: str
    resolution_height: int
    resolution_width: int
    def __init__(self, identifier: str, frame_rate: int, resolution_width: int, resolution_height: int) -> None: ...

class GraspType:
    """
    Members:

      POWER_GRASP

      PRECISION_GRASP

      LATERAL_GRASP

      TRIPOD_GRASP
    """

    LATERAL_GRASP: typing.ClassVar[GraspType]  # value = <GraspType.LATERAL_GRASP: 2>
    POWER_GRASP: typing.ClassVar[GraspType]  # value = <GraspType.POWER_GRASP: 0>
    PRECISION_GRASP: typing.ClassVar[GraspType]  # value = <GraspType.PRECISION_GRASP: 1>
    TRIPOD_GRASP: typing.ClassVar[GraspType]  # value = <GraspType.TRIPOD_GRASP: 3>
    __members__: typing.ClassVar[
        dict[str, GraspType]
    ]  # value = {'POWER_GRASP': <GraspType.POWER_GRASP: 0>, 'PRECISION_GRASP': <GraspType.PRECISION_GRASP: 1>, 'LATERAL_GRASP': <GraspType.LATERAL_GRASP: 2>, 'TRIPOD_GRASP': <GraspType.TRIPOD_GRASP: 3>}
    def __eq__(self, other: typing.Any) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: typing.Any) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    def __str__(self) -> str: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Gripper:
    def __init__(self) -> None: ...
    def close(self) -> None: ...
    def get_normalized_width(self) -> float: ...
    def get_parameters(self) -> GripperConfig: ...
    def get_state(self) -> GripperState: ...
    def grasp(self) -> None: ...
    def is_grasped(self) -> bool: ...
    def open(self) -> None: ...
    def reset(self) -> None: ...
    def set_normalized_width(self, width: float, force: float = 0) -> None: ...
    def shut(self) -> None: ...

class GripperConfig:
    pass

class GripperState:
    pass

class Hand:
    def __init__(self) -> None: ...
    def close(self) -> None: ...
    def get_normalized_joint_poses(self) -> numpy.ndarray[tuple[M], numpy.dtype[numpy.float64]]: ...
    def get_parameters(self) -> HandConfig: ...
    def get_state(self) -> HandState: ...
    def grasp(self) -> None: ...
    def is_grasped(self) -> bool: ...
    def open(self) -> None: ...
    def reset(self) -> None: ...
    def set_normalized_joint_poses(self, q: numpy.ndarray[tuple[M], numpy.dtype[numpy.float64]]) -> None: ...
    def shut(self) -> None: ...

class HandConfig:
    def __init__(self) -> None: ...

class HandState:
    def __init__(self) -> None: ...

class IK:
    def forward(self, q0: numpy.ndarray[tuple[M], numpy.dtype[numpy.float64]], tcp_offset: Pose = ...) -> Pose: ...
    def ik(
        self, pose: Pose, q0: numpy.ndarray[tuple[M], numpy.dtype[numpy.float64]], tcp_offset: Pose = ...
    ) -> numpy.ndarray[tuple[M], numpy.dtype[numpy.float64]] | None: ...

class Pin(IK):
    def __init__(self, path: str, frame_id: str = "fr3_link8", urdf: bool = True) -> None: ...

class Pose:
    def __getstate__(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(16)]: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(
        self, pose_matrix: numpy.ndarray[tuple[typing.Literal[4], typing.Literal[4]], numpy.dtype[numpy.float64]]
    ) -> None: ...
    @typing.overload
    def __init__(
        self,
        rotation: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[3]], numpy.dtype[numpy.float64]],
        translation: numpy.ndarray[tuple[typing.Literal[3]], numpy.dtype[numpy.float64]],
    ) -> None: ...
    @typing.overload
    def __init__(
        self,
        quaternion: numpy.ndarray[tuple[typing.Literal[4]], numpy.dtype[numpy.float64]],
        translation: numpy.ndarray[tuple[typing.Literal[3]], numpy.dtype[numpy.float64]],
    ) -> None: ...
    @typing.overload
    def __init__(
        self, rpy: RPY, translation: numpy.ndarray[tuple[typing.Literal[3]], numpy.dtype[numpy.float64]]
    ) -> None: ...
    @typing.overload
    def __init__(
        self,
        rpy_vector: numpy.ndarray[tuple[typing.Literal[3]], numpy.dtype[numpy.float64]],
        translation: numpy.ndarray[tuple[typing.Literal[3]], numpy.dtype[numpy.float64]],
    ) -> None: ...
    @typing.overload
    def __init__(self, translation: numpy.ndarray[tuple[typing.Literal[3]], numpy.dtype[numpy.float64]]) -> None: ...
    @typing.overload
    def __init__(self, quaternion: numpy.ndarray[tuple[typing.Literal[4]], numpy.dtype[numpy.float64]]) -> None: ...
    @typing.overload
    def __init__(self, rpy: RPY) -> None: ...
    @typing.overload
    def __init__(
        self, rotation: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[3]], numpy.dtype[numpy.float64]]
    ) -> None: ...
    @typing.overload
    def __init__(self, pose: Pose) -> None: ...
    def __mul__(self, arg0: Pose) -> Pose: ...
    def __setstate__(self, arg0: typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(16)]) -> None: ...
    def __str__(self) -> str: ...
    def interpolate(self, dest_pose: Pose, progress: float) -> Pose: ...
    def inverse(self) -> Pose: ...
    def is_close(self, other: Pose, eps_r: float = 1e-08, eps_t: float = 1e-08) -> bool: ...
    def limit_rotation_angle(self, max_angle: float) -> Pose: ...
    def limit_translation_length(self, max_length: float) -> Pose: ...
    def pose_matrix(self) -> numpy.ndarray[tuple[typing.Literal[4], typing.Literal[4]], numpy.dtype[numpy.float64]]: ...
    def rotation_m(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[3]], numpy.dtype[numpy.float64]]: ...
    def rotation_q(self) -> numpy.ndarray[tuple[typing.Literal[4]], numpy.dtype[numpy.float64]]: ...
    def rotation_rpy(self) -> RPY: ...
    def total_angle(self) -> float: ...
    def translation(self) -> numpy.ndarray[tuple[typing.Literal[3]], numpy.dtype[numpy.float64]]: ...
    def xyzrpy(self) -> numpy.ndarray[tuple[typing.Literal[6]], numpy.dtype[numpy.float64]]: ...

class RL(IK):
    def __init__(self, urdf_path: str, max_duration_ms: int = 300) -> None: ...

class RPY:
    pitch: float
    roll: float
    yaw: float
    def __add__(self, arg0: RPY) -> RPY: ...
    def __getstate__(self) -> tuple: ...
    @typing.overload
    def __init__(self, roll: float = 0.0, pitch: float = 0.0, yaw: float = 0.0) -> None: ...
    @typing.overload
    def __init__(self, rpy: numpy.ndarray[tuple[typing.Literal[3]], numpy.dtype[numpy.float64]]) -> None: ...
    def __setstate__(self, arg0: tuple) -> None: ...
    def __str__(self) -> str: ...
    def as_quaternion_vector(self) -> numpy.ndarray[tuple[typing.Literal[4]], numpy.dtype[numpy.float64]]: ...
    def as_vector(self) -> numpy.ndarray[tuple[typing.Literal[3]], numpy.dtype[numpy.float64]]: ...
    def is_close(self, other: RPY, eps: float = 1e-08) -> bool: ...
    def rotation_matrix(
        self,
    ) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[3]], numpy.dtype[numpy.float64]]: ...

class Robot:
    def __init__(self) -> None: ...
    def close(self) -> None: ...
    def get_base_pose_in_world_coordinates(self) -> Pose: ...
    def get_cartesian_position(self) -> Pose: ...
    def get_ik(self) -> IK | None: ...
    def get_joint_position(self) -> numpy.ndarray[tuple[M], numpy.dtype[numpy.float64]]: ...
    def get_parameters(self) -> RobotConfig: ...
    def get_state(self) -> RobotState: ...
    def move_home(self) -> None: ...
    def reset(self) -> None: ...
    def set_cartesian_position(self, pose: Pose) -> None: ...
    def set_joint_position(self, q: numpy.ndarray[tuple[M], numpy.dtype[numpy.float64]]) -> None: ...
    def to_pose_in_robot_coordinates(self, pose_in_world_coordinates: Pose) -> Pose: ...
    def to_pose_in_world_coordinates(self, pose_in_robot_coordinates: Pose) -> Pose: ...

class RobotConfig:
    attachment_site: str
    kinematic_model_path: str
    robot_platform: RobotPlatform
    robot_type: RobotType
    tcp_offset: Pose
    def __init__(self) -> None: ...

class RobotMetaConfig:
    @property
    def dof(self) -> int: ...
    @property
    def joint_limits(self) -> numpy.ndarray[tuple[typing.Literal[2], N], numpy.dtype[numpy.float64]]: ...
    @property
    def q_home(self) -> numpy.ndarray[tuple[M], numpy.dtype[numpy.float64]]: ...

class RobotPlatform:
    """
    Members:

      HARDWARE

      SIMULATION
    """

    HARDWARE: typing.ClassVar[RobotPlatform]  # value = <RobotPlatform.HARDWARE: 1>
    SIMULATION: typing.ClassVar[RobotPlatform]  # value = <RobotPlatform.SIMULATION: 0>
    __members__: typing.ClassVar[
        dict[str, RobotPlatform]
    ]  # value = {'HARDWARE': <RobotPlatform.HARDWARE: 1>, 'SIMULATION': <RobotPlatform.SIMULATION: 0>}
    def __eq__(self, other: typing.Any) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: typing.Any) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    def __str__(self) -> str: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class RobotState:
    pass

class RobotType:
    """
    Members:

      FR3

      UR5e

      SO101

      XArm7
    """

    FR3: typing.ClassVar[RobotType]  # value = <RobotType.FR3: 0>
    SO101: typing.ClassVar[RobotType]  # value = <RobotType.SO101: 2>
    UR5e: typing.ClassVar[RobotType]  # value = <RobotType.UR5e: 1>
    XArm7: typing.ClassVar[RobotType]  # value = <RobotType.XArm7: 3>
    __members__: typing.ClassVar[
        dict[str, RobotType]
    ]  # value = {'FR3': <RobotType.FR3: 0>, 'UR5e': <RobotType.UR5e: 1>, 'SO101': <RobotType.SO101: 2>, 'XArm7': <RobotType.XArm7: 3>}
    def __eq__(self, other: typing.Any) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: typing.Any) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    def __str__(self) -> str: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

def FrankaHandTCPOffset() -> numpy.ndarray[tuple[typing.Literal[4], typing.Literal[4]], numpy.dtype[numpy.float64]]: ...
def IdentityRotMatrix() -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[3]], numpy.dtype[numpy.float64]]: ...
def IdentityRotQuatVec() -> numpy.ndarray[tuple[typing.Literal[4]], numpy.dtype[numpy.float64]]: ...
def IdentityTranslation() -> numpy.ndarray[tuple[typing.Literal[3]], numpy.dtype[numpy.float64]]: ...
def _bootstrap_egl(fn_addr: int, display: int, context: int) -> None: ...
def robots_meta_config(robot_type: RobotType) -> RobotMetaConfig: ...

FR3: RobotType  # value = <RobotType.FR3: 0>
HARDWARE: RobotPlatform  # value = <RobotPlatform.HARDWARE: 1>
LATERAL_GRASP: GraspType  # value = <GraspType.LATERAL_GRASP: 2>
POWER_GRASP: GraspType  # value = <GraspType.POWER_GRASP: 0>
PRECISION_GRASP: GraspType  # value = <GraspType.PRECISION_GRASP: 1>
SIMULATION: RobotPlatform  # value = <RobotPlatform.SIMULATION: 0>
SO101: RobotType  # value = <RobotType.SO101: 2>
TRIPOD_GRASP: GraspType  # value = <GraspType.TRIPOD_GRASP: 3>
UR5e: RobotType  # value = <RobotType.UR5e: 1>
XArm7: RobotType  # value = <RobotType.XArm7: 3>
