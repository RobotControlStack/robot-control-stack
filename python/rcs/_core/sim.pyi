# ATTENTION: auto generated from C++ code, use `make stubgen` to update!
"""
sim module
"""
from __future__ import annotations

import typing

import numpy
import rcs._core.common

__all__ = [
    "CameraType",
    "FrameSet",
    "GuiClient",
    "Sim",
    "SimCameraConfig",
    "SimCameraSet",
    "SimGripper",
    "SimGripperConfig",
    "SimGripperState",
    "SimRobot",
    "SimRobotConfig",
    "SimRobotState",
    "default_free",
    "fixed",
    "free",
    "tracking",
]
M = typing.TypeVar("M", bound=int)

class CameraType:
    """
    Members:

      free

      tracking

      fixed

      default_free
    """

    __members__: typing.ClassVar[
        dict[str, CameraType]
    ]  # value = {'free': <CameraType.free: 0>, 'tracking': <CameraType.tracking: 1>, 'fixed': <CameraType.fixed: 2>, 'default_free': <CameraType.default_free: 3>}
    default_free: typing.ClassVar[CameraType]  # value = <CameraType.default_free: 3>
    fixed: typing.ClassVar[CameraType]  # value = <CameraType.fixed: 2>
    free: typing.ClassVar[CameraType]  # value = <CameraType.free: 0>
    tracking: typing.ClassVar[CameraType]  # value = <CameraType.tracking: 1>
    def __eq__(self, other: typing.Any) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: typing.Any) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    def __str__(self) -> str: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class FrameSet:
    def __init__(self) -> None: ...
    @property
    def color_frames(self) -> dict[str, numpy.ndarray[M, numpy.dtype[numpy.uint8]]]: ...
    @property
    def depth_frames(self) -> dict[str, numpy.ndarray[M, numpy.dtype[numpy.float32]]]: ...
    @property
    def timestamp(self) -> float: ...

class GuiClient:
    def __init__(self, id: str) -> None: ...
    def get_model_bytes(self) -> bytes: ...
    def set_model_and_data(self, arg0: int, arg1: int) -> None: ...
    def sync(self) -> None: ...

class Sim:
    def __init__(self, mjmdl: int, mjdata: int) -> None: ...
    def _start_gui_server(self, id: str) -> None: ...
    def _stop_gui_server(self) -> None: ...
    def is_converged(self) -> bool: ...
    def reset(self) -> None: ...
    def step(self, k: int) -> None: ...
    def step_until_convergence(self) -> None: ...

class SimCameraConfig(rcs._core.common.BaseCameraConfig):
    type: CameraType
    def __init__(
        self, identifier: str, frame_rate: int, resolution_width: int, resolution_height: int, type: CameraType = ...
    ) -> None: ...

class SimCameraSet:
    def __init__(self, sim: Sim, cameras: dict[str, SimCameraConfig], render_on_demand: bool = True) -> None: ...
    def buffer_size(self) -> int: ...
    def clear_buffer(self) -> None: ...
    def get_latest_frameset(self) -> FrameSet | None: ...
    def get_timestamp_frameset(self, ts: float) -> FrameSet | None: ...
    @property
    def _sim(self) -> Sim: ...

class SimGripper(rcs._core.common.Gripper):
    def __init__(self, sim: Sim, cfg: SimGripperConfig) -> None: ...
    def get_parameters(self) -> SimGripperConfig: ...
    def get_state(self) -> SimGripperState: ...
    def set_parameters(self, cfg: SimGripperConfig) -> bool: ...

class SimGripperConfig(rcs._core.common.GripperConfig):
    actuator: str
    collision_geoms: list[str]
    collision_geoms_fingers: list[str]
    epsilon_inner: float
    epsilon_outer: float
    ignored_collision_geoms: list[str]
    joint: str
    seconds_between_callbacks: float
    def __init__(self) -> None: ...
    def add_id(self, id: str) -> None: ...

class SimGripperState(rcs._core.common.GripperState):
    def __init__(self) -> None: ...
    @property
    def collision(self) -> bool: ...
    @property
    def is_moving(self) -> bool: ...
    @property
    def last_commanded_width(self) -> float: ...
    @property
    def last_width(self) -> float: ...
    @property
    def max_unnormalized_width(self) -> float: ...

class SimRobot(rcs._core.common.Robot):
    def __init__(
        self, sim: Sim, ik: rcs._core.common.IK, cfg: SimRobotConfig, register_convergence_callback: bool = True
    ) -> None: ...
    def get_parameters(self) -> SimRobotConfig: ...
    def get_state(self) -> SimRobotState: ...
    def set_joints_hard(self, q: numpy.ndarray[M, numpy.dtype[numpy.float64]]) -> None: ...
    def set_parameters(self, cfg: SimRobotConfig) -> bool: ...

class SimRobotConfig(rcs._core.common.RobotConfig):
    actuators: list[str]
    arm_collision_geoms: list[str]
    attachment_site: str
    base: str
    joint_rotational_tolerance: float
    joints: list[str]
    realtime: bool
    robot_type: rcs._core.common.RobotType
    seconds_between_callbacks: float
    tcp_offset: rcs._core.common.Pose
    trajectory_trace: bool
    def __init__(self) -> None: ...
    def add_id(self, id: str) -> None: ...

class SimRobotState(rcs._core.common.RobotState):
    def __init__(self) -> None: ...
    @property
    def collision(self) -> bool: ...
    @property
    def ik_success(self) -> bool: ...
    @property
    def inverse_tcp_offset(self) -> rcs._core.common.Pose: ...
    @property
    def is_arrived(self) -> bool: ...
    @property
    def is_moving(self) -> bool: ...
    @property
    def previous_angles(self) -> numpy.ndarray[M, numpy.dtype[numpy.float64]]: ...
    @property
    def target_angles(self) -> numpy.ndarray[M, numpy.dtype[numpy.float64]]: ...

default_free: CameraType  # value = <CameraType.default_free: 3>
fixed: CameraType  # value = <CameraType.fixed: 2>
free: CameraType  # value = <CameraType.free: 0>
tracking: CameraType  # value = <CameraType.tracking: 1>
