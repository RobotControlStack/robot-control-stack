import typing
from typing import Annotated, List, Literal, Optional

import numpy as np
import numpy.typing as npt

# _Shape = typing.Tuple[int, ...]
# https://stackoverflow.com/questions/71109838/numpy-typing-with-specific-shape-and-datatype

# DType = TypeVar("DType", bound=np.generic)
Vector3d = Annotated[npt.NDArray[np.float64], Literal[3, 1]]
Vector4d = Annotated[npt.NDArray[np.float64], Literal[4, 1]]
Vector7d = Annotated[npt.NDArray[np.float64], Literal[7, 1]]
Matrix3d = Annotated[npt.NDArray[np.float64], Literal[3, 3]]
Matrix4d = Annotated[npt.NDArray[np.float64], Literal[4, 4]]

class RPY:
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, roll: float, pitch: float, yaw: float) -> None: ...
    def __add__(self, other: RPY) -> RPY: ...

class Pose:
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, pose: Matrix3d) -> None: ...
    @typing.overload
    def __init__(self, rotation: Matrix3d, translation: Vector3d) -> None: ...
    @typing.overload
    def __init__(self, quaternion: Vector4d, translation: Vector3d) -> None: ...
    @typing.overload
    def __init__(self, rpy: RPY, translation: Vector3d) -> None: ...
    def translation(self) -> Vector3d: ...
    def rotation_m(self) -> Matrix3d: ...
    def rotation_q(self) -> Vector4d: ...
    def rotation_rpy(self) -> RPY: ...
    def interpolate(self, dest_pose: Pose, progress: float) -> Pose: ...
    def __mul__(self, other: Pose) -> Pose: ...

class RConfig:
    pass

class RState:
    pass

class GConfig:
    pass

class GState:
    pass

# are python bindings for abstract classes needed?
class Robot:
    def set_paramaters(self, cfg: RConfig) -> bool: ...
    def get_paramaters(self) -> RConfig: ...
    def get_state(self) -> RState: ...
    def get_cartesian_position(self) -> Pose: ...
    def get_joint_position(self) -> Vector7d: ...
    def set_joint_position(self, q: Vector7d) -> None: ...
    def move_home(self) -> None: ...
    def set_cartesian_position(self, pose: Pose) -> None: ...

class Gripper:
    def set_parameters(self, cfg: GConfig) -> bool: ...
    def get_parameters(self) -> GConfig: ...
    def get_state(self) -> GState: ...
    def grasp(self) -> bool: ...
    def release(self) -> None: ...
    def shut(self) -> None: ...

class RobotWithGripper:
    def __init__(self, robot: Robot, gripper: Optional[Gripper]) -> None: ...

class NRobotsWithGripper:
    def __init__(self, robot_with_gripper: List[RobotWithGripper]) -> None: ...
    def set_parameters_r(self, idxs: List[int], cfgs: List[RConfig]) -> None: ...
    def get_parameters_r(self, idxs: List[int]) -> List[RConfig]: ...
    def get_state_r(self, idxs: List[int]) -> List[RState]: ...
    def get_cartesian_position_r(self, idxs: List[int]) -> List[Pose]: ...
    def set_joint_position_r(self, idxs: List[int], q: List[Vector7d]) -> None: ...
    def get_joint_position_r(self, idxs: List[int]) -> List[Vector7d]: ...
    def move_home_r(self, idxs: List[int]) -> None: ...
    def set_cartesian_position_r(self, idxs: List[int], poses: List[Pose]) -> None: ...
    def set_parameters_g(self, idxs: List[int], cfgs: List[GConfig]) -> None: ...
    def get_parameters_g(self, idxs: List[int]) -> List[GConfig]: ...
    def get_state_g(self, idxs: List[int]) -> List[GState]: ...
    def grasp(self, idxs: List[int]) -> List[bool]: ...
    def release(self, idxs: List[int]) -> None: ...
    def shut(self, idxs: List[int]) -> None: ...
