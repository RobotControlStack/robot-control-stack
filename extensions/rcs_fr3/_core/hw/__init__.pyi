# ATTENTION: auto generated from C++ code, use `make stubgen` to update!
"""
rcs fr3 module
"""
from __future__ import annotations

import typing

import numpy
import rcs._core.common

from . import exceptions

__all__ = [
    "FHConfig",
    "FHState",
    "FR3",
    "FR3Config",
    "FR3Load",
    "FR3State",
    "FrankaHand",
    "IKSolver",
    "exceptions",
    "franka_ik",
    "rcs_ik",
]

class FHConfig(rcs._core.common.GripperConfig):
    async_control: bool
    epsilon_inner: float
    epsilon_outer: float
    force: float
    grasping_width: float
    speed: float
    def __init__(self) -> None: ...

class FHState(rcs._core.common.GripperState):
    def __init__(self) -> None: ...
    @property
    def bool_state(self) -> bool: ...
    @property
    def is_grasped(self) -> bool: ...
    @property
    def is_moving(self) -> bool: ...
    @property
    def last_commanded_width(self) -> float: ...
    @property
    def max_unnormalized_width(self) -> float: ...
    @property
    def temperature(self) -> int: ...
    @property
    def width(self) -> float: ...

class FR3(rcs._core.common.Robot):
    def __init__(self, ip: str, ik: rcs._core.common.IK | None = None) -> None: ...
    def automatic_error_recovery(self) -> None: ...
    def controller_set_joint_position(
        self, desired_q: numpy.ndarray[typing.Literal[7], numpy.dtype[numpy.float64]]
    ) -> None: ...
    def double_tap_robot_to_continue(self) -> None: ...
    def get_parameters(self) -> FR3Config: ...
    def get_state(self) -> FR3State: ...
    def osc_set_cartesian_position(self, desired_pos_EE_in_base_frame: rcs._core.common.Pose) -> None: ...
    def set_cartesian_position_ik(
        self,
        pose: rcs._core.common.Pose,
        max_time: float,
        elbow: float | None,
        max_force: float | None = 5,
    ) -> None: ...
    def set_cartesian_position_internal(self, pose: rcs._core.common.Pose) -> None: ...
    def set_default_robot_behavior(self) -> None: ...
    def set_guiding_mode(
        self,
        x: bool = True,
        y: bool = True,
        z: bool = True,
        roll: bool = True,
        pitch: bool = True,
        yaw: bool = True,
        elbow: bool = True,
    ) -> None: ...
    def set_parameters(self, cfg: FR3Config) -> bool: ...
    def stop_control_thread(self) -> None: ...
    def zero_torque_guiding(self) -> None: ...

class FR3Config(rcs._core.common.RobotConfig):
    async_control: bool
    ik_solver: IKSolver
    load_parameters: FR3Load | None
    nominal_end_effector_frame: rcs._core.common.Pose | None
    speed_factor: float
    tcp_offset: rcs._core.common.Pose
    world_to_robot: rcs._core.common.Pose | None
    def __init__(self) -> None: ...

class FR3Load:
    f_x_cload: numpy.ndarray[typing.Literal[3], numpy.dtype[numpy.float64]] | None
    load_inertia: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[3]], numpy.dtype[numpy.float64]] | None
    load_mass: float
    def __init__(self) -> None: ...

class FR3State(rcs._core.common.RobotState):
    def __init__(self) -> None: ...

class FrankaHand(rcs._core.common.Gripper):
    def __init__(self, ip: str, cfg: FHConfig) -> None: ...
    def get_parameters(self) -> FHConfig: ...
    def get_state(self) -> FHState: ...
    def homing(self) -> bool: ...
    def is_grasped(self) -> bool: ...
    def set_parameters(self, cfg: FHConfig) -> bool: ...

class IKSolver:
    """
    Members:

      franka_ik

      rcs_ik
    """

    __members__: typing.ClassVar[
        dict[str, IKSolver]
    ]  # value = {'franka_ik': <IKSolver.franka_ik: 0>, 'rcs_ik': <IKSolver.rcs_ik: 1>}
    franka_ik: typing.ClassVar[IKSolver]  # value = <IKSolver.franka_ik: 0>
    rcs_ik: typing.ClassVar[IKSolver]  # value = <IKSolver.rcs_ik: 1>
    def __eq__(self, other: typing.Any) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: typing.Any) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    def __str__(self) -> str: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

franka_ik: IKSolver  # value = <IKSolver.franka_ik: 0>
rcs_ik: IKSolver  # value = <IKSolver.rcs_ik: 1>
